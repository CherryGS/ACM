对于形式为 $r\times 2^k+1$ 的质数模数 , 可以利用原根取代单位根 , 从而避免精度损失

```cpp
namespace NTT {
    typedef long long ll;

    /* 常见原根表 */
    // 998244353 -> 3
    const int P = 998244353, G = 3;

    /* 最大长度 , 保证补充到了 2 的次幂 */
    const int max_le = (1<<21)+1;

    int w[max_le], inv[max_le];

    int mod(int x) { return x >= P ? x - P : x; }

    ll ksm(ll bs, int x) {
        ll ans = 1;
        while(x) {
            if(x & 1) { ans = ans * bs % P; }
            bs = bs * bs % P;
            x >>= 1;
        }
        return ans;
    }
 
    void init(int len) {
        inv[1] = 1;
        for(int i=2;i<=len;i++) { inv[i] = mod(P - 1ll * (P / i) * inv[P%i] % P); }
        for(int i=1;i<len;i<<=1) {
            int wn = ksm(G, (P - 1) / (i<<1));
            for(int j=0, ww=1; j<i; j++, ww=1ll*ww*wn%P) { w[i+j] = ww; }
        }
    }
    
    void change(ll y[], int len) {
        int i, j, k;
        for (i = 1, j = len / 2; i < len - 1; i++) {
            if(i < j) { swap(y[i], y[j]); }
            k = len / 2;
            while (j >= k) { j = j - k; k = k / 2; }
            if(j < k) { j += k; }
        }
    }
 
    void ntt(ll f[], int len, int op) {
        change(f, len);
        for(int i=1;i<len;i<<=1){
            for(int j=0;j<len;j+=i<<1) {
                for(int k=0;k<i;k++) {
                    int x = f[j+k], y = 1ll * f[i+j+k]* w[i+k]%P;
                    f[j+k] = mod(x+y);
                    f[i+j+k] = mod(x-y+P);
                }
            }
        }
        if(op == -1) {
            reverse(&f[1],&f[len]);
            for(int i=0;i<len;i++) { f[i] = 1ll * f[i] * inv[len] % P; };
        }
    }
    /* NTT 过程辅助数组 */
    ll a[max_le], b[max_le];

    void solve(ll x1[], ll x2[], int len1, int len2, ll ans[]) {
        int len = 1;
        while(len < (len1 + len2)) { len <<= 1; }
        init(len);
        for(int i=0; i<len; i++) {
            if(i < len1) { a[i] = x1[i]; }
            else { a[i] = 0; }
            if(i < len2) { b[i] = x2[i]; }
            else { b[i] = 0; }
        }
        ntt(a, len, 1); ntt(b, len, 1);
        for(int i=0; i<len; i++) { a[i] = a[i] * b[i] % P; }
        ntt(a, len, -1);
        for(int i=0; i<len; i++) { ans[i] = a[i]; }
    }
};
```

原根表

```txt
常用素数：
P = 1004535809  ====>  pr = 3
P = 998244353  =====>  pr = 3
prime               r   k   g
3                   1   1   2
5                   1   2   2
17                  1   4   3
97                  3   5   5
193                 3   6   5
257                 1   8   3
7681                15  9   17
12289               3   12  11
40961               5   13  3
65537               1   16  3
786433              3   18  10
5767169             11  19  3
7340033             7   20  3
23068673            11  21  3
104857601           25  22  3
167772161           5   25  3
469762049           7   26  3
1004535809          479 21  3
2013265921          15  27  31
2281701377          17  27  3
3221225473          3   30  5
75161927681         35  31  3
77309411329         9   33  7
206158430209        3   36  22
2061584302081       15  37  7
2748779069441       5   39  3
6597069766657       3   41  5
39582418599937      9   42  5
79164837199873      9   43  5
263882790666241     15  44  7
1231453023109121    35  45  3
1337006139375617    19  46  3
3799912185593857    27  47  5
4222124650659841    15  48  19
7881299347898369    7   50  6
31525197391593473   7   52  3
180143985094819841  5   55  6
1945555039024054273 27  56  5
4179340454199820289 29  57  3
```

