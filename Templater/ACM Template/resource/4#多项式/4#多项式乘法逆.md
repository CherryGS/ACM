采用倍增的思想

首先有 $[x^0]f^{-1}(x)$ 为 $[x^0]f(x)$ 在模数下的逆元

不妨假定多项式长度为 2 的幂

如果现在 , 我们算出了 $f^{-1}_0(x)$ , 满足 $f(x) \cdot  f^{-1}_0 \equiv 1 \ (mod\  x^{\frac{n}{2}})$ , 那么如果答案为 $f^{-1}(x)$ , 则有
$$
f^{-1}(x) - f^{-1}_0(x) \equiv 0\ (mod \ x^{\frac{n}{2}})
$$
两边平方并同乘 $f(x)$ , 整理则有
$$
f^{-1}(x) \equiv f^{-1}_0(x) (2-f(x)f^{-1}_0(x))\ (mod\ x^n)
$$
直接计算即可

需要保证多项式常数项在模数意义下有逆元存在

```cpp
void solve() {
    // a 为系数数组 , mod 为模数 , pre 为辅助数组
    inv[0] = get_inv(a[0], mod);
    for(int i=2; i<n*2; i<<=1) {
        FFT(a, inv, i, i/2, pre, mod);
        pre[0] -= 2;
        for(int j=0; j<i; j++) { pre[j] = -pre[j]; }
        FFT(inv, pre, i/2, i, inv, mod);
    }
    for(int i=0; i<n; i++) { if(inv[i] < 0) { inv[i] += mod; } }
    for(int i=0; i<n; i++) { cout << inv[i] << ' '; }
    cout << '\n';
}
```

