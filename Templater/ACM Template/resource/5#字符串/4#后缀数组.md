## SA 与 RK (字符串下标从1开始)

$sa[i]$ 被定义为字符串 $s[0\cdots n]$ 所有后缀排序后第 $i$ 小的后缀的开头位置 , 排名 -> 后缀

$rk[i]$ 被定义为字符串 $s[0\cdots n]$ 以第 $i$ 个字符开头的后缀的排名 , 后缀 -> 排名

有 $sa[rk[i]] = rk[sa[i]] = i$ 

## height 数组

$height[i]$ 被定义为 $LCP(sa[i], sa[i-1])$ , 即排名为 $i$ 的后缀和排名为 $i-1$ 的后缀的最长公共前缀



```cpp
struct SA {
    #define mx_n 100001*4
    /* 数组开到上限两倍 */
    int sa[mx_n], rk[mx_n], cnt[mx_n], id[mx_n], px[mx_n], od[mx_n];
    int height[mx_n];
    /* 注意字符串下标需要从 0 开始 , 但是 sa/rk/height 下标从 1 开始 , 其所代表的字符串下标也从 1 开始 */
    void init_sa(char *s, int n) {
        int m = 'z', i, w, p;
        auto cmp = [&](int &x, int &y, int &w) -> bool { return od[x] == od[y] && od[x+w] == od[y+w]; };
        for(i=1; i<=n; ++i) { ++cnt[rk[i] = s[i-1]]; }
        for(i=1; i<=m; ++i) { cnt[i] += cnt[i-1]; }
        for(i=n; i>=1; --i) { sa[cnt[rk[i]]--] = i; }
        for(w=1; w<=n; w<<=1, m=p) {
            for(p=0, i=n; i>n-w; --i) { id[++p] = i; }
            for(i=1; i<=n; ++i) { if(sa[i] > w) { id[++p] = sa[i] - w; } }
            memset(cnt, 0, sizeof cnt);
            for(i=1; i<=n; ++i) { ++cnt[px[i] = rk[id[i]]]; }
            for(i=1; i<=m; ++i) { cnt[i] += cnt[i-1]; }
            for(i=n; i>=1; --i) { sa[cnt[px[i]]--] = id[i]; }
            memcpy(od, rk, sizeof od);
            for(p=0, i=1; i<=n; ++i) { rk[sa[i]] = cmp(sa[i], sa[i-1], w) ? p : ++p; }
            if(p == n) { for(i=1; i<=n; ++i) { sa[rk[i]] = i; } break; }
        }
        cacu_h(s, n);
    }
    void cacu_h(char *s, int n) {
        for(int i=1, k=0; i<=n; ++i) {
            if(rk[i] == 0) { continue; }
            if(k) { --k; }
            while(s[i+k-1] == s[sa[rk[i]-1]+k]) { ++k; }
            height[rk[i]] = k;
        }
    }
};
```

