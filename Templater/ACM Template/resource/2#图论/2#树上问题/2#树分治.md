

如果需要计算的树上信息不受树形态的影响 , 如根节点选取的影响 ，而且可以将子树内的信息单独统计，将多个子树的信息合并统计，那么可以考虑树分治。

不会受到影响的信息有 简单路径长度

会受到影响的信息有 LCA

如果对于每一层分治，计算的总复杂度为 $\Theta(N)$ ，那么 k 次递归的复杂度就是 $\Theta(kN)$

如果能保证递归次数为 $\log$ 级别，那么复杂度就会是 $\Theta(N\log N)$ ，而从重心分治就可以保证最多递归 $\log N$ 次

```cpp
const int mx_n=100000;
vector<int> to[mx_n+100];
int son[mx_n+100]; // 经过处理后的每个点的儿子个数
bool vis[mx_n+100]; // 该点是否在分治时作为子树的根

void add(int f, int t) {
    to[f].push_back(t);
}

/* 获取通过 vis 分隔的当前子树的大小 */
int get_size(int u, int fa) {
    int sum = 1;
    for(int i=0; i<to[u].size(); i++) {
        int v = to[u][i];
        if(v != fa && !vis[v]) {
            sum += get_size(v, u);
        }
    }
    return sum;
}

/* 获取通过 vis 分隔的当前子树的重心 */
int get_root(int u, int fa, int n) {
    int pre = 0, weight = 0, id = 0;
    son[u] = 1;
    for(int i=0; i<to[u].size(); i++) {
        int v = to[u][i];
        if(v != fa && !vis[v]) {
            id = get_root(v, u, n);
            if(id != 0) { return id; }
            son[u] += son[v];
            weight = max(weight, son[v]);
        }
    }
    pre = max(pre, n - son[u]);
    // 树的重心可能有两个，此处任取了一个
    if(pre <= n/2) { return u; }
    return 0;
}

void clear() { }

void cacu(int u, int fa) { }

void update(int u, int fa) { }

void sol(int u) {
    vis[u] = 1;
    clear();
    // 计算当前节点为根的答案
    for(int i=0; i<to[u].size(); i++) {
        int v = to[u][i];
        if(!vis[v]) {
            cacu(v, u);
            update(v, u);
        }
    }
    // 向子树递归
    for(int i=0; i<to[u].size(); i++) {
        int v = to[u][i];
        if(!vis[v]) {
            sol(get_root(v, u, get_size(v, u)));
        }
    }
}

void solve(int T) {
    sol(get_root(1, 1, n));
}
```

- [洛谷P3806](https://www.luogu.com.cn/problem/P3806)
- [洛谷P2634](https://www.luogu.com.cn/problem/P2634)
- [洛谷P4178](https://www.luogu.com.cn/problem/P4178)

