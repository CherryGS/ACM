dinic+spfa
```cpp
const int mxn = 5000; // 最大点数
const int mxm = 50000; // 最大边数
struct dinic {
    int s, t; // 源，汇
    bool vis[mxn+10];
    ll dis[mxn+10];
    ll w[mxm*2+10], c[mxm*2+10];
    int h[mxn+10], nx[mxm*2+10], to[mxm*2+10], cnt=1; // 链式前向星, cnt=1 方便找到反边
    int cur[mxn+10]; // 当前弧优化辅助数组
    void clear_map() { cnt = 1; for(int i=1; i<=mxn; i++) h[i] = 0; }
    void add(int f, int t, int co, int ca) {
        nx[++cnt] = h[f]; h[f] = cnt; to[cnt] = t; w[cnt] = co; c[cnt] = ca;
        nx[++cnt] = h[t]; h[t] = cnt; to[cnt] = f; w[cnt] = -co; c[cnt] = 0;
    }
    bool spfa() {
        memcpy(cur, h, sizeof h); // 当前弧优化
        memset(dis, 0x3f, sizeof dis);
        queue<int> q; q.push(s);
        dis[s] = 0; vis[s] = 1;
        int v;
        while(!q.empty()) {
            auto u = q.front();
            q.pop();
            vis[u] = 0;
            for(int i=h[u]; i; i=nx[i]) {
                v = to[i];
                if(c[i] && dis[v] > dis[u] + w[i]) {
                    dis[v] = dis[u] + w[i];
                    if(!vis[v]) { q.push(v); vis[v] = 1; }
                }
            }
        }
        return dis[t] < dis[0];
    }
    ll dfs(cint u, ll cap, ll &val) {
        if(u == t) { return cap; }
        ll sum = 0; int v; vis[u] = 1;
        for(int i=cur[u]; i; i=nx[i]) {
            cur[u] = i; v = to[i];
            if(c[i] > 0 && !vis[v] && dis[v] == dis[u] + w[i]) {
                ll d = dfs(v, min(cap, c[i]), val);
                if(d) { c[i] -= d; c[i^1] += d; cap -= d; sum += d; val += 1ll * d * w[i]; }
                if(cap == 0) { break; }
            }
        }
        vis[u] = 0;
        return sum;
    }
    pair<ll, ll> max_flow(int s, int t) {
        this->s = s;
        this->t = t;
        ll flow = 0, res = 0;
        while(spfa()) { flow += dfs(s, inf_int, res); }
        return {flow, res};
    }
};
```